/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => hackmdPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// sharer.ts
var import_obsidian = require("obsidian");
var shareNote = (key, content, permission) => {
  const data = JSON.stringify({
    "content": content,
    "writePermission": permission.writePermission,
    "commentPermission": permission.commentPermission,
    "readPermission": permission.readPermission
  });
  const requestParams = {
    method: "post",
    url: "https://api.hackmd.io/v1/notes",
    headers: {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + key,
      "Cookie": "locale=dev"
    },
    body: data
  };
  return (0, import_obsidian.requestUrl)(requestParams);
};
var updataNote = (key, content, id) => {
  const data = JSON.stringify({
    "content": content
  });
  const requestParams = {
    method: "patch",
    url: "https://api.hackmd.io/v1/notes/" + id,
    headers: {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + key,
      "Cookie": "locale=dev"
    },
    body: data
  };
  return (0, import_obsidian.requestUrl)(requestParams);
};
var getNote = (key, id) => {
  const requestParams = {
    method: "get",
    url: "https://api.hackmd.io/v1/notes/" + id,
    headers: {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + key,
      "Cookie": "locale=dev"
    }
  };
  return (0, import_obsidian.requestUrl)(requestParams);
};

// node_modules/diff/lib/index.mjs
function Diff() {
}
Diff.prototype = {
  diff: function diff(oldString, newString) {
    var _options$timeout;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var callback = options.callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    var self = this;
    function done(value) {
      value = self.postProcess(value, options);
      if (callback) {
        setTimeout(function() {
          callback(value);
        }, 0);
        return true;
      } else {
        return value;
      }
    }
    oldString = this.castInput(oldString, options);
    newString = this.castInput(newString, options);
    oldString = this.removeEmpty(this.tokenize(oldString, options));
    newString = this.removeEmpty(this.tokenize(newString, options));
    var newLen = newString.length, oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    if (options.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
    var abortAfterTimestamp = Date.now() + maxExecutionTime;
    var bestPath = [{
      oldPos: -1,
      lastComponent: void 0
    }];
    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0, options);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(buildValues(self, bestPath[0].lastComponent, newString, oldString, self.useLongestToken));
    }
    var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath = void 0;
        var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        var canAdd = false;
        if (addPath) {
          var addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        var canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = self.addToPath(addPath, true, false, 0, options);
        } else {
          basePath = self.addToPath(removePath, false, true, 1, options);
        }
        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath, options);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    }
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback();
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  addToPath: function addToPath(path, added, removed, oldPosInc, options) {
    var last = path.lastComponent;
    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: last.count + 1,
          added,
          removed,
          previousComponent: last.previousComponent
        }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added,
          removed,
          previousComponent: last
        }
      };
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath, options) {
    var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldString[oldPos + 1], newString[newPos + 1], options)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options.oneChangePerToken) {
        basePath.lastComponent = {
          count: 1,
          previousComponent: basePath.lastComponent,
          added: false,
          removed: false
        };
      }
    }
    if (commonCount && !options.oneChangePerToken) {
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent,
        added: false,
        removed: false
      };
    }
    basePath.oldPos = oldPos;
    return newPos;
  },
  equals: function equals(left, right, options) {
    if (options.comparator) {
      return options.comparator(left, right);
    } else {
      return left === right || options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize(value) {
    return Array.from(value);
  },
  join: function join(chars) {
    return chars.join("");
  },
  postProcess: function postProcess(changeObjects) {
    return changeObjects;
  }
};
function buildValues(diff2, lastComponent, newString, oldString, useLongestToken) {
  var components = [];
  var nextComponent;
  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }
  components.reverse();
  var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function(value2, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value2.length ? oldValue : value2;
        });
        component.value = diff2.join(value);
      } else {
        component.value = diff2.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff2.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
    }
  }
  return components;
}
var characterDiff = new Diff();
function longestCommonPrefix(str1, str2) {
  var i;
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[i] != str2[i]) {
      return str1.slice(0, i);
    }
  }
  return str1.slice(0, i);
}
function longestCommonSuffix(str1, str2) {
  var i;
  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {
    return "";
  }
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {
      return str1.slice(-i);
    }
  }
  return str1.slice(-i);
}
function replacePrefix(string, oldPrefix, newPrefix) {
  if (string.slice(0, oldPrefix.length) != oldPrefix) {
    throw Error("string ".concat(JSON.stringify(string), " doesn't start with prefix ").concat(JSON.stringify(oldPrefix), "; this is a bug"));
  }
  return newPrefix + string.slice(oldPrefix.length);
}
function replaceSuffix(string, oldSuffix, newSuffix) {
  if (!oldSuffix) {
    return string + newSuffix;
  }
  if (string.slice(-oldSuffix.length) != oldSuffix) {
    throw Error("string ".concat(JSON.stringify(string), " doesn't end with suffix ").concat(JSON.stringify(oldSuffix), "; this is a bug"));
  }
  return string.slice(0, -oldSuffix.length) + newSuffix;
}
function removePrefix(string, oldPrefix) {
  return replacePrefix(string, oldPrefix, "");
}
function removeSuffix(string, oldSuffix) {
  return replaceSuffix(string, oldSuffix, "");
}
function maximumOverlap(string1, string2) {
  return string2.slice(0, overlapCount(string1, string2));
}
function overlapCount(a, b) {
  var startA = 0;
  if (a.length > b.length) {
    startA = a.length - b.length;
  }
  var endB = b.length;
  if (a.length < b.length) {
    endB = a.length;
  }
  var map = Array(endB);
  var k = 0;
  map[0] = 0;
  for (var j = 1; j < endB; j++) {
    if (b[j] == b[k]) {
      map[j] = map[k];
    } else {
      map[j] = k;
    }
    while (k > 0 && b[j] != b[k]) {
      k = map[k];
    }
    if (b[j] == b[k]) {
      k++;
    }
  }
  k = 0;
  for (var i = startA; i < a.length; i++) {
    while (k > 0 && a[i] != b[k]) {
      k = map[k];
    }
    if (a[i] == b[k]) {
      k++;
    }
  }
  return k;
}
var extendedWordChars = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";
var tokenizeIncludingWhitespace = new RegExp("[".concat(extendedWordChars, "]+|\\s+|[^").concat(extendedWordChars, "]"), "ug");
var wordDiff = new Diff();
wordDiff.equals = function(left, right, options) {
  if (options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }
  return left.trim() === right.trim();
};
wordDiff.tokenize = function(value) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var parts;
  if (options.intlSegmenter) {
    if (options.intlSegmenter.resolvedOptions().granularity != "word") {
      throw new Error('The segmenter passed must have a granularity of "word"');
    }
    parts = Array.from(options.intlSegmenter.segment(value), function(segment) {
      return segment.segment;
    });
  } else {
    parts = value.match(tokenizeIncludingWhitespace) || [];
  }
  var tokens = [];
  var prevPart = null;
  parts.forEach(function(part) {
    if (/\s/.test(part)) {
      if (prevPart == null) {
        tokens.push(part);
      } else {
        tokens.push(tokens.pop() + part);
      }
    } else if (/\s/.test(prevPart)) {
      if (tokens[tokens.length - 1] == prevPart) {
        tokens.push(tokens.pop() + part);
      } else {
        tokens.push(prevPart + part);
      }
    } else {
      tokens.push(part);
    }
    prevPart = part;
  });
  return tokens;
};
wordDiff.join = function(tokens) {
  return tokens.map(function(token, i) {
    if (i == 0) {
      return token;
    } else {
      return token.replace(/^\s+/, "");
    }
  }).join("");
};
wordDiff.postProcess = function(changes, options) {
  if (!changes || options.oneChangePerToken) {
    return changes;
  }
  var lastKeep = null;
  var insertion = null;
  var deletion = null;
  changes.forEach(function(change) {
    if (change.added) {
      insertion = change;
    } else if (change.removed) {
      deletion = change;
    } else {
      if (insertion || deletion) {
        dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);
      }
      lastKeep = change;
      insertion = null;
      deletion = null;
    }
  });
  if (insertion || deletion) {
    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);
  }
  return changes;
};
function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {
  if (deletion && insertion) {
    var oldWsPrefix = deletion.value.match(/^\s*/)[0];
    var oldWsSuffix = deletion.value.match(/\s*$/)[0];
    var newWsPrefix = insertion.value.match(/^\s*/)[0];
    var newWsSuffix = insertion.value.match(/\s*$/)[0];
    if (startKeep) {
      var commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);
      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);
      deletion.value = removePrefix(deletion.value, commonWsPrefix);
      insertion.value = removePrefix(insertion.value, commonWsPrefix);
    }
    if (endKeep) {
      var commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);
      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);
      deletion.value = removeSuffix(deletion.value, commonWsSuffix);
      insertion.value = removeSuffix(insertion.value, commonWsSuffix);
    }
  } else if (insertion) {
    if (startKeep) {
      insertion.value = insertion.value.replace(/^\s*/, "");
    }
    if (endKeep) {
      endKeep.value = endKeep.value.replace(/^\s*/, "");
    }
  } else if (startKeep && endKeep) {
    var newWsFull = endKeep.value.match(/^\s*/)[0], delWsStart = deletion.value.match(/^\s*/)[0], delWsEnd = deletion.value.match(/\s*$/)[0];
    var newWsStart = longestCommonPrefix(newWsFull, delWsStart);
    deletion.value = removePrefix(deletion.value, newWsStart);
    var newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);
    deletion.value = removeSuffix(deletion.value, newWsEnd);
    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);
    startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));
  } else if (endKeep) {
    var endKeepWsPrefix = endKeep.value.match(/^\s*/)[0];
    var deletionWsSuffix = deletion.value.match(/\s*$/)[0];
    var overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);
    deletion.value = removeSuffix(deletion.value, overlap);
  } else if (startKeep) {
    var startKeepWsSuffix = startKeep.value.match(/\s*$/)[0];
    var deletionWsPrefix = deletion.value.match(/^\s*/)[0];
    var _overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);
    deletion.value = removePrefix(deletion.value, _overlap);
  }
}
var wordWithSpaceDiff = new Diff();
wordWithSpaceDiff.tokenize = function(value) {
  var regex = new RegExp("(\\r?\\n)|[".concat(extendedWordChars, "]+|[^\\S\\n\\r]+|[^").concat(extendedWordChars, "]"), "ug");
  return value.match(regex) || [];
};
var lineDiff = new Diff();
lineDiff.tokenize = function(value, options) {
  if (options.stripTrailingCr) {
    value = value.replace(/\r\n/g, "\n");
  }
  var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];
    if (i % 2 && !options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      retLines.push(line);
    }
  }
  return retLines;
};
lineDiff.equals = function(left, right, options) {
  if (options.ignoreWhitespace) {
    if (!options.newlineIsToken || !left.includes("\n")) {
      left = left.trim();
    }
    if (!options.newlineIsToken || !right.includes("\n")) {
      right = right.trim();
    }
  } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {
    if (left.endsWith("\n")) {
      left = left.slice(0, -1);
    }
    if (right.endsWith("\n")) {
      right = right.slice(0, -1);
    }
  }
  return Diff.prototype.equals.call(this, left, right, options);
};
function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
var sentenceDiff = new Diff();
sentenceDiff.tokenize = function(value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var cssDiff = new Diff();
cssDiff.tokenize = function(value) {
  return value.split(/([{}:;,]|\s+)/);
};
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
var jsonDiff = new Diff();
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;
jsonDiff.castInput = function(value, options) {
  var undefinedReplacement = options.undefinedReplacement, _options$stringifyRep = options.stringifyReplacer, stringifyReplacer = _options$stringifyRep === void 0 ? function(k, v) {
    return typeof v === "undefined" ? undefinedReplacement : v;
  } : _options$stringifyRep;
  return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff.equals = function(left, right, options) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"), options);
};
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key, obj);
  }
  var i;
  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }
  var canonicalizedObj;
  if ("[object Array]" === Object.prototype.toString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, _key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
var arrayDiff = new Diff();
arrayDiff.tokenize = function(value) {
  return value.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value) {
  return value;
};

// main.ts
function generateMergeConflictFile(text1, text2) {
  const differences = diffLines(text1, text2);
  const result = [];
  let pendingOriginal = [];
  let pendingModified = [];
  differences.forEach((part) => {
    if (part.removed) {
      pendingOriginal.push(...part.value.replace(/\n$/, "").split("\n"));
    } else if (part.added) {
      pendingModified.push(...part.value.replace(/\n$/, "").split("\n"));
    } else {
      if (pendingOriginal.length > 0 && pendingModified.length > 0) {
        result.push("<<<<<<< HEAD");
        result.push(...pendingOriginal);
        result.push("=======");
        result.push(...pendingModified);
        result.push(">>>>>>>");
      } else if (pendingOriginal.length > 0) {
        result.push(...pendingOriginal);
      } else if (pendingModified.length > 0) {
        result.push(...pendingModified);
      }
      pendingOriginal = [];
      pendingModified = [];
      result.push(...part.value.replace(/\n$/, "").split("\n"));
    }
  });
  if (pendingOriginal.length > 0 && pendingModified.length > 0) {
    result.push("<<<<<<< HEAD");
    result.push(...pendingOriginal);
    result.push("=======");
    result.push(...pendingModified);
    result.push(">>>>>>>");
  } else if (pendingOriginal.length > 0) {
    result.push(...pendingOriginal);
  } else if (pendingModified.length > 0) {
    result.push(...pendingModified);
  }
  return result.join("\n");
}
var DEFAULT_SETTINGS = {
  apiToken: "None",
  commentPermission: "guest",
  readPermission: "guest"
};
var hackmdPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "share",
      name: "Share article",
      editorCallback: async (editor, view) => {
        const curContent = editor.getValue();
        const yamlRegex = /^---\n([\s\S]*?)\n---/;
        const match = curContent.match(yamlRegex);
        if (match) {
          const yamlContent = match[1];
          const yamlData = (0, import_obsidian2.parseYaml)(yamlContent);
          new PopWindows(this.app, this.settings, editor, view, yamlData).open();
          return;
        }
        new PopWindows(this.app, this.settings, editor, view, {}).open();
      }
    });
    this.addSettingTab(new SettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
function updateYamlContent(content, updates) {
  const yamlRegex = /^---\n([\s\S]*?)\n---/;
  if (yamlRegex.test(content)) {
    return content.replace(yamlRegex, (match, p1) => {
      const yamlData = (0, import_obsidian2.parseYaml)(p1) || {};
      Object.assign(yamlData, updates);
      const newYaml = (0, import_obsidian2.stringifyYaml)(yamlData).trim();
      return `---
${newYaml}
---`;
    });
  } else {
    const newYaml = (0, import_obsidian2.stringifyYaml)(updates).trim();
    return `---
${newYaml}
---

${content}`;
  }
}
function updateEditorYaml(editor, updates) {
  const content = editor.getValue();
  const newContent = updateYamlContent(content, updates);
  editor.setValue(newContent);
}
async function createRemoteVersionFile(app, folderPath, originalFileName, content, remoteInfo) {
  try {
    const fileExtension = originalFileName.split(".").pop();
    const baseName = originalFileName.replace(`.${fileExtension}`, "");
    const newFileName = `${baseName}-${remoteInfo.permission}.${fileExtension}`;
    const fullPath = `${folderPath}/${newFileName}`;
    const yamlUpdates = {
      remote_permission: remoteInfo.permission,
      pull_time: remoteInfo.pullTime
    };
    const contentWithYaml = updateYamlContent(content, yamlUpdates);
    const file = await app.vault.create(fullPath, contentWithYaml);
    return file;
  } catch (error) {
    new import_obsidian2.Notice(`Failed to create remote version file: ${error.message}`);
    return null;
  }
}
var PopWindows = class extends import_obsidian2.Modal {
  constructor(app, settings, editor, view, yamlData) {
    super(app);
    this.checkNote = async (noteId) => {
      if (noteId) {
        try {
          const response = await getNote(this.token, noteId);
          const content = response.json.content;
          this.previewArea.setText(content);
          this.previewArea.value = content;
          this.idLabel.setText(noteId);
          this.currId = noteId;
        } catch (error) {
          this.idLabel.setText("\u7121\u6548\u7684 ID");
          this.previewArea.setText("");
          this.previewArea.value = "";
          this.currId = "";
          new import_obsidian2.Notice(`\u7121\u6CD5\u7372\u53D6\u7B46\u8A18: ${error.message}`);
        }
      } else {
        this.idLabel.setText("\u7121");
        this.currId = "";
        this.previewArea.value = "";
        this.previewArea.setText("");
      }
    };
    this.createDropdown = async (dropdownContainer, labelText, defaultValue, options) => {
      const noteId = this.yamlData[`hackmd-id-owner`];
      await this.checkNote(noteId);
      const wrapper = dropdownContainer.createEl("div", { cls: "dropdown-wrapper" });
      wrapper.createEl("label", { text: labelText, cls: "dropdown-label" });
      const customSelect = wrapper.createEl("div", { cls: "custom-select" });
      const selectedDisplay = customSelect.createEl("div", {
        cls: "selected-option",
        text: defaultValue
      });
      const optionsList = customSelect.createEl("div", { cls: "options-list" });
      let selectedValue = defaultValue;
      options.forEach((option) => {
        const optionEl = optionsList.createEl("div", {
          cls: "option",
          text: option
        });
        optionEl.addEventListener("click", async () => {
          selectedDisplay.setText(option);
          optionsList.classList.remove("show");
          selectedValue = option;
          const noteId2 = this.yamlData[`hackmd-id-${option}`];
          await this.checkNote(noteId2);
        });
      });
      selectedDisplay.addEventListener("click", (e) => {
        e.stopPropagation();
        document.querySelectorAll(".options-list.show").forEach((list) => {
          if (list !== optionsList) {
            list.classList.remove("show");
          }
        });
        optionsList.classList.toggle("show");
      });
      return () => selectedValue;
    };
    this.token = settings.apiToken;
    this.editor = editor;
    this.view = view;
    this.yamlData = yamlData;
    this.settings = settings;
    this.currId = "";
  }
  async onOpen() {
    const { contentEl } = this;
    this.titleEl.setText("\u5206\u4EAB\u8A2D\u5B9A");
    const dropdownContainer = contentEl.createEl("div", { cls: "dropdown-container" });
    dropdownContainer.createEl("label", { text: "\u524D\u6B21\u5206\u4EAB id \uFF1A", cls: "id-a" });
    this.idLabel = dropdownContainer.createEl("label", {
      text: "\u7121",
      cls: "id-a id-s"
    });
    this.previewArea = dropdownContainer.createEl("textarea", { cls: "preview-area", attr: { rows: "10" } });
    const getEditValue = await this.createDropdown(dropdownContainer, "\u7DE8\u8F2F\u6B0A\u9650 \uFF1A", "owner", ["owner", "signed_in", "guest"]);
    new import_obsidian2.Setting(contentEl).setName("\u5206\u4EAB").setDesc("\u82E5\u5DF2\u7D93\u5206\u4EAB\u904E\u5247\u6703\u5F37\u5236\u8986\u84CB\u7DDA\u4E0A\u7248\u672C").addButton((btn) => btn.setButtonText("Push").setCta().onClick(async () => {
      var _a;
      const writePermission = getEditValue();
      const fileContent = this.editor.getValue();
      const title = "# " + ((_a = this.view.file) == null ? void 0 : _a.basename) + "\n";
      const contentWithoutYaml = fileContent.replace(/^---\n[\s\S]*?\n---\n/, "");
      const content = title + contentWithoutYaml;
      if (this.currId) {
        try {
          const response = await updataNote(this.token, content, this.currId);
          const message = `Note shared\uFF08Updata\uFF09 successfully!`;
          new import_obsidian2.Notice(message, 1e4).noticeEl;
        } catch (error) {
          console.log(error);
          new import_obsidian2.Notice("Push\uFF08Updata\uFF09failed: " + error.message);
        }
      } else {
        try {
          const response = await shareNote(this.token, content, { writePermission, readPermission: this.settings.readPermission, commentPermission: this.settings.commentPermission });
          const link = response.json.publishLink;
          const id = response.json.id;
          const message = `Note shared successfully!`;
          const btn2 = new import_obsidian2.Notice(message, 1e4).noticeEl;
          btn2.addEventListener("click", () => {
            window.open(link, "_blank");
          });
          await navigator.clipboard.writeText(link);
          updateEditorYaml(this.editor, {
            ["hackmd-link-" + writePermission]: link,
            ["hackmd-id-" + writePermission]: id
          });
        } catch (error) {
          console.log(error);
          new import_obsidian2.Notice("Push failed: " + error.message);
        }
      }
      this.close();
    }));
    new import_obsidian2.Setting(contentEl).setName("\u5408\u4F75").setDesc("\u900F\u904E\u4E0A\u65B9\u9810\u89BD\u6846\u4FEE\u6539\u5F8C\u6309\u4E0B Pull \u6703\u5408\u4F75\u81F3\u672C\u5730\u6587\u4EF6\u4E26\u4FDD\u7559\u5408\u4F75\u885D\u7A81").addButton((btn) => btn.setButtonText("Pull").setCta().onClick(async () => {
      if (!this.currId) {
        new import_obsidian2.Notice("No online version");
        return;
      }
      const oldContent = this.editor.getValue();
      const oldContentWithoutYaml = oldContent.replace(/^---\n[\s\S]*?\n---\n/, "");
      const match = oldContent.match(/^(---\n[\s\S]*?\n---)/);
      const yaml = match ? match[1] + "\n" : "";
      const newContent = this.previewArea.value;
      const content = generateMergeConflictFile(oldContentWithoutYaml, newContent);
      this.editor.setValue(yaml + content);
      const message = `Pull successfully`;
      new import_obsidian2.Notice(message, 1e4).noticeEl;
      this.close();
    }));
    new import_obsidian2.Setting(contentEl).setName("\u5F37\u5236\u5408\u4F75").setDesc("\u900F\u904E\u4E0A\u65B9\u9810\u89BD\u6846\u4FEE\u6539\u5F8C\u6309\u4E0B Pull \u6703\u5F37\u5236\u8986\u84CB\u672C\u5730\u6587\u4EF6").addButton((btn) => btn.setButtonText("Pull").setCta().onClick(async () => {
      if (!this.currId) {
        new import_obsidian2.Notice("No online version");
        return;
      }
      const oldContent = this.editor.getValue();
      const match = oldContent.match(/^(---\n[\s\S]*?\n---)/);
      const yaml = match ? match[1] + "\n" : "";
      const newContent = this.previewArea.value;
      this.editor.setValue(yaml + newContent);
      const message = `Pull successfully`;
      new import_obsidian2.Notice(message, 1e4).noticeEl;
      this.close();
    }));
    new import_obsidian2.Setting(contentEl).setName("\u62C9\u53D6\u5230\u65B0\u6A94\u6848").setDesc("\u900F\u904E\u4E0A\u65B9\u9810\u89BD\u6846\u4FEE\u6539\u5F8C\u6309\u4E0B Pull \u6703\u62C9\u53D6\u9060\u7AEF\u7248\u672C\u4E26\u5728\u7576\u524D\u76EE\u9304\u5EFA\u7ACB\u65B0\u6A94\u6848").addButton(
      (btn) => btn.setButtonText("Pull").setCta().onClick(async () => {
        if (!this.currId) {
          new import_obsidian2.Notice("No online version");
          return;
        }
        const writePermission = getEditValue();
        const oldContent = this.editor.getValue();
        const match = oldContent.match(/^(---\n[\s\S]*?\n---)/);
        const yaml = match ? match[1] + "\n" : "";
        const newContent = this.previewArea.value;
        const currentFile = this.app.workspace.getActiveFile();
        if (!currentFile) {
          new import_obsidian2.Notice("No active file");
          return;
        }
        const remoteInfo = {
          permission: writePermission,
          pullTime: new Date().toISOString().replace("T", " ").replace(/:/g, ".")
        };
        const newFile = await createRemoteVersionFile(
          this.app,
          currentFile.parent.path,
          currentFile.name,
          yaml + newContent,
          remoteInfo
        );
        if (newFile) {
          new import_obsidian2.Notice(`Created remote version file: ${newFile.name}`, 5e3);
        }
        this.close();
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("hackmd api token").setDesc("\u53BB\u641E\u4E00\u500B\u5427").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.apiToken).onChange(async (value) => {
      this.plugin.settings.apiToken = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("commentPermission").setDesc("\u8A55\u8AD6\u8A2D\u5B9A").addDropdown((dropdown) => dropdown.addOptions({
      "disabled": "\u95DC\u9589",
      "forbidden": "\u7981\u7528",
      "owner": "\u50C5\u64C1\u6709\u8005",
      "signed_in": "\u767B\u5165\u7528\u6236",
      "guest": "\u8A2A\u5BA2"
    }).setValue(this.plugin.settings.commentPermission || "guest").onChange(async (value) => {
      this.plugin.settings.commentPermission = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("readPermission").setDesc("\u6AA2\u8996\u8A2D\u5B9A").addDropdown((dropdown) => dropdown.addOptions({
      "owner": "\u50C5\u64C1\u6709\u8005",
      "signed_in": "\u767B\u5165\u7528\u6236",
      "guest": "\u8A2A\u5BA2"
    }).setValue(this.plugin.settings.commentPermission || "guest").onChange(async (value) => {
      this.plugin.settings.commentPermission = value;
      await this.plugin.saveSettings();
    }));
  }
};
